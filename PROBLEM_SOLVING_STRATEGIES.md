# ðŸ§  Common Problem-Solving Techniques

## 1. Divide and Conquer
- **Idea**: Break the problem into smaller parts, solve them recursively, and combine the results.
- **Example**: Merge Sort, Quick Sort, Binary Search

## 2. Greedy Algorithms
- **Idea**: Make the locally optimal choice at each step, hoping it leads to a global optimum.
- **Example**: Dijkstraâ€™s algorithm, Huffman coding, Activity selection

## 3. Dynamic Programming
- **Idea**: Solve subproblems once and store their results to avoid redundant computation.
- **Example**: Fibonacci sequence, Knapsack problem, Matrix chain multiplication

## 4. Backtracking
- **Idea**: Try out solutions incrementally and abandon them if they donâ€™t lead to a valid solution.
- **Example**: Sudoku solver, N-Queens problem, Maze solving

## 5. Brute Force
- **Idea**: Try all possible solutions and pick the best one.
- **Example**: Password cracking, Simple search algorithms

## 6. Recursion
- **Idea**: Solve a problem by solving smaller instances of the same problem.
- **Example**: Tree traversal, Factorial, Tower of Hanoi

## 7. Memoization
- **Idea**: Cache results of expensive function calls to avoid repeated work.
- **Example**: Optimized recursive Fibonacci, Caching in web apps

## 8. Two-Pointer Technique
- **Idea**: Use two pointers to scan through data efficiently.
- **Example**: Finding pairs in a sorted array, Sliding window problems

## 9. Bit Manipulation
- **Idea**: Use binary operations to solve problems efficiently.
- **Example**: Checking even/odd, Subset generation, XOR tricks

## 10. Graph Traversal
- **Idea**: Explore nodes and edges using BFS or DFS.
- **Example**: Pathfinding, Cycle detection, Connected components
